{
  "examples": [
    {
      "name": "Async/Await with Error Handling",
      "example": "Demonstrates async/await with error handling using try/catch.\n\n```javascript\nasync function fetchData(url) {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) throw new Error('Network response was not ok');\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    // Error handling\n    console.error('Fetch error:', error);\n  }\n}\n\n// Usage\nfetchData('https://api.example.com/data');\n```"
    },
    {
      "name": "Custom Promise Implementation",
      "example": "Shows how to create a custom Promise to simulate async behavior.\n\n```javascript\nfunction delay(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n// Usage\ndelay(1000).then(() => {\n  // Executes after 1 second\n});\n```"
    },
    {
      "name": "Generators for Iteration",
      "example": "Uses generators to create custom iterators.\n\n```javascript\nfunction* idGenerator() {\n  let id = 1;\n  while (true) {\n    yield id++;\n  }\n}\n\nconst gen = idGenerator();\n// gen.next().value returns incremental id\n```"
    },
    {
      "name": "Advanced Destructuring",
      "example": "Extracts nested object values using destructuring.\n\n```javascript\nconst user = {\n  id: 42,\n  name: 'Alice',\n  address: {\n    city: 'Wonderland',\n    zip: '12345'\n  }\n};\n\nconst { name, address: { city } } = user;\n// name is 'Alice', city is 'Wonderland'\n```"
    },
    {
      "name": "Tagged Template Literals",
      "example": "Demonstrates a tag function for custom string processing.\n\n```javascript\nfunction highlight(strings, ...values) {\n  return strings.reduce((result, str, i) => result + str + (values[i] ? `<b>${values[i]}</b>` : ''), '');\n}\n\nconst name = 'Bob';\nconst message = highlight`Hello, ${name}! Welcome.`;\n// message: 'Hello, <b>Bob</b>! Welcome.'\n```"
    },
    {
      "name": "Spread and Rest Operators",
      "example": "Illustrates use of spread to combine arrays and rest to gather parameters.\n\n```javascript\n// Spread\nconst arr1 = [1, 2];\nconst arr2 = [3, 4];\nconst combined = [...arr1, ...arr2];\n\n// Rest\nfunction sum(...nums) {\n  return nums.reduce((a, b) => a + b, 0);\n}\n\n// combined is [1, 2, 3, 4] and sum(1,2,3) returns 6\n```"
    },
    {
      "name": "Using Symbol for Unique Keys",
      "example": "Utilizes Symbol to create unique object keys.\n\n```javascript\nconst uniqueKey = Symbol('key');\nconst obj = {\n  [uniqueKey]: 'value',\n  regularKey: 'another value'\n};\n\n// uniqueKey property is non-enumerable in normal loops\n```"
    },
    {
      "name": "Custom Iterator with Symbol.iterator",
      "example": "Implements custom iteration using Symbol.iterator.\n\n```javascript\nconst customIterable = {\n  data: [10, 20, 30],\n  [Symbol.iterator]() {\n    let index = 0;\n    const data = this.data;\n    return {\n      next() {\n        if (index < data.length) {\n          return { value: data[index++], done: false };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  }\n};\n\n// for...of loop iterates over customIterable\n```"
    },
    {
      "name": "Map and Set Advanced Usage",
      "example": "Shows advanced usage of Map and Set for data storage.\n\n```javascript\nconst map = new Map();\nmap.set('a', 1);\nmap.set('b', 2);\n\nconst set = new Set([1, 2, 2, 3]); // duplicates removed\n\n// map.get('a') returns 1; set has values 1, 2, 3\n```"
    },
    {
      "name": "Proxy for Object Interception",
      "example": "Uses Proxy to intercept get and set operations on an object.\n\n```javascript\nconst target = {};\nconst handler = {\n  get(obj, prop) {\n    // Log property access\n    console.log(`Accessing ${prop}`);\n    return obj[prop];\n  },\n  set(obj, prop, value) {\n    // Validate before setting\n    if (prop === 'age' && value < 0) {\n      throw new Error('Age cannot be negative');\n    }\n    obj[prop] = value;\n    return true;\n  }\n};\n\nconst proxy = new Proxy(target, handler);\nproxy.name = 'Charlie';\n// proxy.age = -1 would throw an error\n```"
    },
    {
      "name": "Reflect API Usage",
      "example": "Utilizes Reflect API for object operations in a safe manner.\n\n```javascript\nconst obj = { x: 10 };\nReflect.set(obj, 'y', 20);\nconst xVal = Reflect.get(obj, 'x');\n// xVal is 10; obj now has property y = 20\n```"
    },
    {
      "name": "Module Pattern with Closures",
      "example": "Implements a module pattern to encapsulate private state.\n\n```javascript\nconst CounterModule = (function() {\n  let count = 0; // private variable\n  return {\n    increment() { count++; },\n    getCount() { return count; }\n  };\n})();\n\nCounterModule.increment();\n// CounterModule.getCount() returns 1\n```"
    },
    {
      "name": "Currying Functions",
      "example": "Transforms a function into a curried version.\n\n```javascript\nfunction curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn(...args);\n    } else {\n      return (...more) => curried(...args, ...more);\n    }\n  };\n}\n\n// Example usage\nfunction add(a, b, c) {\n  return a + b + c;\n}\n\nconst curriedAdd = curry(add);\n// curriedAdd(1)(2)(3) returns 6\n```"
    },
    {
      "name": "Partial Application",
      "example": "Creates a function with some arguments pre-applied.\n\n```javascript\nfunction partial(fn, ...presetArgs) {\n  return function(...laterArgs) {\n    return fn(...presetArgs, ...laterArgs);\n  };\n}\n\nfunction multiply(a, b) {\n  return a * b;\n}\n\nconst double = partial(multiply, 2);\n// double(5) returns 10\n```"
    },
    {
      "name": "Memoization Function",
      "example": "Caches function results to optimize performance.\n\n```javascript\nfunction memoize(fn) {\n  const cache = new Map();\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Example usage\nconst factorial = memoize(function(n) {\n  return n <= 1 ? 1 : n * factorial(n - 1);\n});\n// factorial(5) computes recursively with caching\n```"
    },
    {
      "name": "Recursive Function with Tail Recursion",
      "example": "Implements tail recursion for optimized recursive calls.\n\n```javascript\nfunction tailFactorial(n, acc = 1) {\n  if (n <= 1) return acc;\n  return tailFactorial(n - 1, n * acc);\n}\n\n// tailFactorial(5) returns 120\n```"
    },
    {
      "name": "Understanding the Event Loop",
      "example": "Illustrates microtasks vs macrotasks scheduling.\n\n```javascript\nconsole.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout'); // macrotask\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise'); // microtask\n});\n\nconsole.log('End');\n// Order: Start, End, Promise, Timeout\n```"
    },
    {
      "name": "Debounce Function Implementation",
      "example": "Prevents a function from being called too frequently.\n\n```javascript\nfunction debounce(fn, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn.apply(this, args), delay);\n  };\n}\n\n// Usage: debounce a resize event handler\n```"
    },
    {
      "name": "Throttle Function Implementation",
      "example": "Ensures a function is called at most once per interval.\n\n```javascript\nfunction throttle(fn, interval) {\n  let lastCall = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastCall >= interval) {\n      lastCall = now;\n      fn.apply(this, args);\n    }\n  };\n}\n\n// Usage: throttle a scroll event handler\n```"
    },
    {
      "name": "Custom Error Types",
      "example": "Defines custom error classes for better error handling.\n\n```javascript\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\n// Throwing a custom error\n// throw new ValidationError('Invalid input');\n```"
    },
    {
      "name": "Async Iterators",
      "example": "Demonstrates asynchronous iteration with for-await-of.\n\n```javascript\nasync function* asyncGenerator() {\n  let i = 0;\n  while (i < 3) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    yield i++;\n  }\n}\n\n(async () => {\n  for await (const num of asyncGenerator()) {\n    // Iterates over async values\n  }\n})();\n```"
    },
    {
      "name": "WeakMap for Data Privacy",
      "example": "Uses WeakMap to store private data for objects.\n\n```javascript\nconst privateData = new WeakMap();\n\nclass Person {\n  constructor(name) {\n    privateData.set(this, { name });\n  }\n  getName() {\n    return privateData.get(this).name;\n  }\n}\n\nconst alice = new Person('Alice');\n// alice.getName() returns 'Alice'\n```"
    },
    {
      "name": "Singleton Pattern",
      "example": "Ensures only one instance of a class is created.\n\n```javascript\nclass Singleton {\n  constructor() {\n    if (Singleton.instance) {\n      return Singleton.instance;\n    }\n    // Initialize singleton instance\n    Singleton.instance = this;\n  }\n}\n\nconst instance1 = new Singleton();\nconst instance2 = new Singleton();\n// instance1 === instance2\n```"
    },
    {
      "name": "Observer Pattern",
      "example": "Implements a simple observer pattern for event handling.\n\n```javascript\nclass Observable {\n  constructor() {\n    this.observers = [];\n  }\n  subscribe(fn) {\n    this.observers.push(fn);\n  }\n  notify(data) {\n    this.observers.forEach(fn => fn(data));\n  }\n}\n\nconst observable = new Observable();\nobservable.subscribe(data => {\n  // React to data update\n});\n\n// observable.notify('Update');\n```"
    },
    {
      "name": "Mediator Pattern",
      "example": "Uses a mediator to facilitate communication between objects.\n\n```javascript\nclass Mediator {\n  constructor() {\n    this.channels = {};\n  }\n  subscribe(channel, fn) {\n    if (!this.channels[channel]) {\n      this.channels[channel] = [];\n    }\n    this.channels[channel].push(fn);\n  }\n  publish(channel, data) {\n    if (this.channels[channel]) {\n      this.channels[channel].forEach(fn => fn(data));\n    }\n  }\n}\n\nconst mediator = new Mediator();\nmediator.subscribe('event', data => {\n  // Handle event data\n});\n// mediator.publish('event', 'Hello');\n```"
    },
    {
      "name": "Decorator Pattern",
      "example": "Enhances functions by wrapping them with additional behavior.\n\n```javascript\nfunction decorate(fn) {\n  return function(...args) {\n    // Pre-processing\n    const result = fn(...args);\n    // Post-processing\n    return result;\n  };\n}\n\nfunction greet(name) {\n  return `Hello, ${name}`;\n}\n\nconst decoratedGreet = decorate(greet);\n// decoratedGreet('Dave') returns 'Hello, Dave'\n```"
    },
    {
      "name": "Factory Pattern",
      "example": "Creates objects without exposing the instantiation logic.\n\n```javascript\nfunction createUser(name, role) {\n  return { name, role };\n}\n\nconst user = createUser('Eve', 'admin');\n// user: { name: 'Eve', role: 'admin' }\n```"
    },
    {
      "name": "Mixin Pattern",
      "example": "Combines multiple objects into one using mixins.\n\n```javascript\nconst canEat = {\n  eat() { /* eating behavior */ }\n};\n\nconst canWalk = {\n  walk() { /* walking behavior */ }\n};\n\nfunction mixin(target, ...sources) {\n  Object.assign(target, ...sources);\n}\n\nclass Person {}\n\nmixin(Person.prototype, canEat, canWalk);\n// Person instances have eat and walk methods\n```"
    },
    {
      "name": "Event Emitter",
      "example": "Implements a basic event emitter for managing events.\n\n```javascript\nclass EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n  on(event, listener) {\n    if (!this.events[event]) this.events[event] = [];\n    this.events[event].push(listener);\n  }\n  emit(event, data) {\n    if (this.events[event]) {\n      this.events[event].forEach(listener => listener(data));\n    }\n  }\n}\n\nconst emitter = new EventEmitter();\nemitter.on('data', data => {\n  // Handle event data\n});\n// emitter.emit('data', { key: 'value' });\n```"
    },
    {
      "name": "Immutable Object with Object.freeze",
      "example": "Creates an immutable object using Object.freeze.\n\n```javascript\nconst obj = {\n  a: 1,\n  b: { c: 2 }\n};\n\nObject.freeze(obj);\n// obj.a cannot be changed; however, nested objects are not frozen by default\n```"
    },
    {
      "name": "Deep Freeze Utility",
      "example": "Recursively freezes an object to make it fully immutable.\n\n```javascript\nfunction deepFreeze(obj) {\n  Object.keys(obj).forEach(key => {\n    if (typeof obj[key] === 'object' && obj[key] !== null) {\n      deepFreeze(obj[key]);\n    }\n  });\n  return Object.freeze(obj);\n}\n\nconst person = { name: 'Alice', address: { city: 'Wonderland' } };\ndeepFreeze(person);\n// All properties are now immutable\n```"
    },
    {
      "name": "Custom Async Function Wrapper",
      "example": "Wraps a synchronous function to return a promise asynchronously.\n\n```javascript\nfunction asyncWrapper(fn) {\n  return function(...args) {\n    return new Promise((resolve) => {\n      resolve(fn(...args));\n    });\n  };\n}\n\nfunction add(a, b) {\n  return a + b;\n}\n\nconst asyncAdd = asyncWrapper(add);\n// asyncAdd(2, 3) returns a promise resolving to 5\n```"
    },
    {
      "name": "Dynamic Import",
      "example": "Uses dynamic import() to load modules on demand.\n\n```javascript\n// Assume module.js exports a function named greet\nasync function loadModule() {\n  const module = await import('./module.js');\n  module.greet('World');\n}\n\n// loadModule() loads module dynamically\n```"
    },
    {
      "name": "Optional Chaining",
      "example": "Safely accesses nested object properties with optional chaining.\n\n```javascript\nconst user = { profile: { name: 'John' } };\nconst userName = user?.profile?.name; // 'John'\nconst age = user?.profile?.age; // undefined\n```"
    },
    {
      "name": "Nullish Coalescing Operator",
      "example": "Provides default values using the nullish coalescing operator.\n\n```javascript\nconst foo = null ?? 'default'; // 'default'\nconst bar = 0 ?? 42;       // 0, because 0 is not null or undefined\n```"
    },
    {
      "name": "Regex Named Capture Groups",
      "example": "Uses named capture groups in regular expressions (ES2018+).\n\n```javascript\nconst regex = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\nconst match = regex.exec('2025-02-10');\n// match.groups contains { year: '2025', month: '02', day: '10' }\n```"
    },
    {
      "name": "Private Class Fields",
      "example": "Uses private class fields (introduced in ES2022) for data encapsulation.\n\n```javascript\nclass Counter {\n  #count = 0; // private field\n  increment() {\n    this.#count++;\n  }\n  getCount() {\n    return this.#count;\n  }\n}\n\nconst counter = new Counter();\ncounter.increment();\n// counter.getCount() returns 1\n```"
    },
    {
      "name": "Using WeakSet",
      "example": "Demonstrates how to use WeakSet to store weakly held objects.\n\n```javascript\nconst ws = new WeakSet();\nlet obj = {};\nws.add(obj);\n// obj can be garbage collected when no other references exist\n```"
    },
    {
      "name": "Function Binding with .bind()",
      "example": "Binds a function's this context to a specific object.\n\n```javascript\nconst module = {\n  x: 42,\n  getX() {\n    return this.x;\n  }\n};\n\nconst unboundGetX = module.getX;\nconst boundGetX = unboundGetX.bind(module);\n// boundGetX() returns 42\n```"
    },
    {
      "name": "IIFE and Scope Isolation",
      "example": "Uses an Immediately Invoked Function Expression to isolate scope.\n\n```javascript\n(function() {\n  const secret = 'hidden';\n  // secret is not accessible outside\n})();\n```"
    },
    {
      "name": "Debounce vs Throttle Comparison",
      "example": "Highlights the difference between debounce and throttle functions.\n\n```javascript\n// Debounce: triggers after events stop\nfunction debounce(fn, delay) {\n  let timeout;\n  return (...args) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => fn(...args), delay);\n  };\n}\n\n// Throttle: triggers at most once per interval\nfunction throttle(fn, interval) {\n  let lastTime = 0;\n  return (...args) => {\n    const now = Date.now();\n    if (now - lastTime >= interval) {\n      lastTime = now;\n      fn(...args);\n    }\n  };\n}\n```\n"
    },
    {
      "name": "Event Delegation in DOM",
      "example": "Uses event delegation to handle events on dynamically added elements.\n\n```javascript\n// HTML: <ul id=\"list\"><li>Item 1</li><li>Item 2</li></ul>\n\nconst list = document.getElementById('list');\nlist.addEventListener('click', event => {\n  if (event.target.tagName === 'LI') {\n    // Handle list item click\n  }\n});\n```\n"
    },
    {
      "name": "Custom Elements (Web Components)",
      "example": "Defines a custom HTML element using the Web Components API.\n\n```javascript\nclass MyElement extends HTMLElement {\n  connectedCallback() {\n    this.innerHTML = '<p>Custom Element Content</p>';\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n// Use <my-element></my-element> in HTML\n```\n"
    },
    {
      "name": "Shadow DOM Usage",
      "example": "Encapsulates styles and markup using the Shadow DOM.\n\n```javascript\nclass ShadowComponent extends HTMLElement {\n  constructor() {\n    super();\n    const shadow = this.attachShadow({ mode: 'open' });\n    shadow.innerHTML = `<style>p { color: red; }</style><p>Shadow DOM Content</p>`;\n  }\n}\n\ncustomElements.define('shadow-comp', ShadowComponent);\n```\n"
    },
    {
      "name": "MutationObserver",
      "example": "Observes changes in the DOM using MutationObserver.\n\n```javascript\nconst targetNode = document.getElementById('content');\nconst observer = new MutationObserver(mutations => {\n  mutations.forEach(mutation => {\n    // Handle DOM changes\n  });\n});\nobserver.observe(targetNode, { childList: true, subtree: true });\n```\n"
    },
    {
      "name": "Promise.allSettled",
      "example": "Handles multiple promises regardless of rejection or fulfillment.\n\n```javascript\nconst promises = [\n  Promise.resolve(1),\n  Promise.reject('error'),\n  Promise.resolve(3)\n];\n\nPromise.allSettled(promises).then(results => {\n  // results is an array with status for each promise\n});\n```\n"
    },
    {
      "name": "Using Fetch with Async/Await",
      "example": "Performs an HTTP request using fetch with async/await.\n\n```javascript\nasync function getData() {\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n  // data contains parsed JSON\n}\n\ngetData();\n```\n"
    },
    {
      "name": "Proxy-based Validation",
      "example": "Uses Proxy to validate object properties on assignment.\n\n```javascript\nconst validator = {\n  set(obj, prop, value) {\n    if (prop === 'age' && (typeof value !== 'number' || value < 0)) {\n      throw new Error('Invalid age');\n    }\n    obj[prop] = value;\n    return true;\n  }\n};\n\nconst person = new Proxy({}, validator);\nperson.age = 30; // valid\n// person.age = -5; would throw an error\n```\n"
    },
    {
      "name": "Currying with Arrow Functions",
      "example": "Demonstrates concise currying using arrow functions.\n\n```javascript\nconst curriedSum = a => b => a + b;\n// curriedSum(2)(3) returns 5\n```\n"
    },
    {
      "name": "Async Generators for Data Streams",
      "example": "Processes streaming data asynchronously using async generators.\n\n```javascript\nasync function* streamData() {\n  const data = [1, 2, 3];\n  for (const item of data) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    yield item;\n  }\n}\n\n(async () => {\n  for await (const value of streamData()) {\n    // Process streamed value\n  }\n})();\n```\n"
    },
    {
      "name": "Function Composition",
      "example": "Combines multiple functions into one.\n\n```javascript\nconst compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x);\n\nconst add = a => a + 1;\nconst double = a => a * 2;\n\n// Compose: first add then double\nconst addThenDouble = compose(double, add);\n// addThenDouble(3) returns 8\n```"
    },
    {
      "name": "Concurrency Control with Async/Await",
      "example": "Limits the number of concurrent async operations.\n\n```javascript\nasync function limitConcurrency(tasks, limit) {\n  const results = [];\n  const executing = [];\n  \n  for (const task of tasks) {\n    const p = Promise.resolve().then(() => task());\n    results.push(p);\n    \n    if (limit <= tasks.length) {\n      const e = p.then(() => executing.splice(executing.indexOf(e), 1));\n      executing.push(e);\n      if (executing.length >= limit) {\n        await Promise.race(executing);\n      }\n    }\n  }\n  return Promise.all(results);\n}\n\n// Example: use an array of async tasks with a concurrency limit\n```"
    },
    {
      "name": "LRU Cache Implementation",
      "example": "Creates a simple Least Recently Used (LRU) cache using a Map.\n\n```javascript\nclass LRUCache {\n  constructor(limit = 5) {\n    this.limit = limit;\n    this.cache = new Map();\n  }\n  get(key) {\n    if (!this.cache.has(key)) return undefined;\n    const value = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, value);\n    return value;\n  }\n  set(key, value) {\n    if (this.cache.has(key)) this.cache.delete(key);\n    else if (this.cache.size === this.limit) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n    this.cache.set(key, value);\n  }\n}\n\n// Usage: const cache = new LRUCache(3);\n```"
    },
    {
      "name": "Safe JSON Parsing",
      "example": "Parses JSON without throwing errors by returning null on failure.\n\n```javascript\nfunction safeJsonParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    return null; // Return null on parse error\n  }\n}\n\n// safeJsonParse('{\"key\": \"value\"}') returns an object\n```"
    },
    {
      "name": "Chainable API Design",
      "example": "Creates chainable methods to enable a fluent interface.\n\n```javascript\nclass Chainable {\n  constructor(value = 0) {\n    this.value = value;\n  }\n  add(num) {\n    this.value += num;\n    return this;\n  }\n  subtract(num) {\n    this.value -= num;\n    return this;\n  }\n  get() {\n    return this.value;\n  }\n}\n\n// Usage: new Chainable(5).add(3).subtract(2).get(); // returns 6\n```"
    },
    {
      "name": "Custom Event System with CustomEvent",
      "example": "Uses CustomEvent to create and dispatch custom browser events.\n\n```javascript\n// Create a custom event with data\nconst event = new CustomEvent('my-event', { detail: { key: 'value' } });\n\n// Listen for the event\ndocument.addEventListener('my-event', e => {\n  // e.detail contains the event data\n});\n\n// Dispatch the event\ndocument.dispatchEvent(event);\n```"
    },
    {
      "name": "Immediate Debounce",
      "example": "Implements debounce with an immediate invocation option.\n\n```javascript\nfunction debounceImmediate(fn, delay) {\n  let timeout;\n  return function(...args) {\n    const callNow = !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(() => timeout = null, delay);\n    if (callNow) fn.apply(this, args);\n  };\n}\n\n// Usage: const debouncedFn = debounceImmediate(myFunction, 300);\n```"
    },
    {
      "name": "Time Slicing with requestIdleCallback",
      "example": "Schedules non-critical tasks during the browser's idle time.\n\n```javascript\nif ('requestIdleCallback' in window) {\n  requestIdleCallback(deadline => {\n    while (deadline.timeRemaining() > 0 && tasks.length) {\n      // Process tasks during idle time\n      tasks.shift()();\n    }\n  });\n}\n```"
    },
    {
      "name": "Computed Properties with Object.defineProperty",
      "example": "Creates a computed property on an object using a getter.\n\n```javascript\nconst obj = { a: 2 };\nObject.defineProperty(obj, 'double', {\n  get() { return this.a * 2; }\n});\n// obj.double returns 4\n```"
    },
    {
      "name": "Dynamic Property Definition with Proxy",
      "example": "Uses Proxy to dynamically generate property values on access.\n\n```javascript\nconst handler = {\n  get(target, prop) {\n    if (!(prop in target)) {\n      target[prop] = `Value for ${prop}`;\n    }\n    return target[prop];\n  }\n};\n\nconst dynamicObj = new Proxy({}, handler);\n// dynamicObj.anyProp returns 'Value for anyProp'\n```"
    },
    {
      "name": "Binary Search Implementation",
      "example": "Performs binary search on a sorted array.\n\n```javascript\nfunction binarySearch(arr, target) {\n  let left = 0, right = arr.length - 1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return mid;\n    else if (arr[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n  return -1; // Not found\n}\n\n// binarySearch([1,2,3,4,5], 3) returns index 2\n```"
    },
    {
      "name": "BigInt Arithmetic",
      "example": "Performs arithmetic with BigInt for handling large integers.\n\n```javascript\nconst a = BigInt(Number.MAX_SAFE_INTEGER);\nconst b = BigInt(1);\nconst sum = a + b;\n// sum is a BigInt beyond Number.MAX_SAFE_INTEGER\n```"
    },
    {
      "name": "Simple State Machine",
      "example": "Implements a basic finite state machine with transitions.\n\n```javascript\nclass StateMachine {\n  constructor(initialState) {\n    this.state = initialState;\n  }\n  transition(newState) {\n    // Optionally, add validation logic here\n    this.state = newState;\n  }\n}\n\nconst fsm = new StateMachine('idle');\nfsm.transition('running');\n// fsm.state is 'running'\n```"
    },
    {
      "name": "Custom map/reduce/filter Implementation",
      "example": "Re-implements array methods for educational purposes.\n\n```javascript\nArray.prototype.myMap = function(fn) {\n  const result = [];\n  for (let i = 0; i < this.length; i++) {\n    result.push(fn(this[i], i, this));\n  }\n  return result;\n};\n\nArray.prototype.myFilter = function(fn) {\n  const result = [];\n  for (let i = 0; i < this.length; i++) {\n    if (fn(this[i], i, this)) result.push(this[i]);\n  }\n  return result;\n};\n\nArray.prototype.myReduce = function(fn, initial) {\n  let accumulator = initial === undefined ? this[0] : initial;\n  for (let i = initial === undefined ? 1 : 0; i < this.length; i++) {\n    accumulator = fn(accumulator, this[i], i, this);\n  }\n  return accumulator;\n};\n```"
    },
    {
      "name": "Linked List Implementation",
      "example": "Builds a simple singly linked list data structure.\n\n```javascript\nclass ListNode {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nclass LinkedList {\n  constructor() {\n    this.head = null;\n  }\n  append(value) {\n    const newNode = new ListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      return;\n    }\n    let current = this.head;\n    while (current.next) {\n      current = current.next;\n    }\n    current.next = newNode;\n  }\n}\n\n// Usage: const list = new LinkedList(); list.append(1);\n```"
    },
    {
      "name": "Binary Search Tree Implementation",
      "example": "Implements a basic binary search tree with insertion.\n\n```javascript\nclass BSTNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n  insert(value) {\n    const newNode = new BSTNode(value);\n    if (!this.root) {\n      this.root = newNode;\n      return;\n    }\n    let current = this.root;\n    while (true) {\n      if (value < current.value) {\n        if (!current.left) {\n          current.left = newNode;\n          return;\n        }\n        current = current.left;\n      } else {\n        if (!current.right) {\n          current.right = newNode;\n          return;\n        }\n        current = current.right;\n      }\n    }\n  }\n}\n\n// Usage: const bst = new BinarySearchTree(); bst.insert(10);\n```"
    },
    {
      "name": "Deep Clone Function",
      "example": "Recursively creates a deep copy of an object or array.\n\n```javascript\nfunction deepClone(obj) {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(deepClone);\n  const cloned = {};\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      cloned[key] = deepClone(obj[key]);\n    }\n  }\n  return cloned;\n}\n\n// deepClone({ a: { b: 2 } }) returns a deep copy\n```"
    },
    {
      "name": "Email Validation with Regex",
      "example": "Validates an email address using a regular expression.\n\n```javascript\nfunction isValidEmail(email) {\n  const regex = /^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$/;\n  return regex.test(email);\n}\n\n// isValidEmail('test@example.com') returns true\n```"
    },
    {
      "name": "URL Manipulation",
      "example": "Uses URL and URLSearchParams to modify query parameters.\n\n```javascript\nconst url = new URL('https://example.com?page=1');\nurl.searchParams.set('page', 2);\n// url.toString() returns 'https://example.com/?page=2'\n```"
    },
    {
      "name": "Using structuredClone",
      "example": "Clones objects using the modern structuredClone API.\n\n```javascript\nconst original = { a: 1, b: { c: 2 } };\nconst copy = structuredClone(original);\n// copy is a deep clone of original\n```"
    },
    {
      "name": "Pub/Sub System with Map",
      "example": "Implements a publish-subscribe system using a Map for listeners.\n\n```javascript\nclass PubSub {\n  constructor() {\n    this.events = new Map();\n  }\n  subscribe(event, listener) {\n    if (!this.events.has(event)) this.events.set(event, []);\n    this.events.get(event).push(listener);\n  }\n  publish(event, data) {\n    const listeners = this.events.get(event) || [];\n    listeners.forEach(listener => listener(data));\n  }\n}\n\n// Usage: const ps = new PubSub();\n```"
    },
    {
      "name": "Logical Assignment Operators",
      "example": "Utilizes logical assignment operators (||=, &&=, ??=) to simplify code.\n\n```javascript\nlet config = {};\nconfig.timeout ??= 3000;  // sets timeout if undefined\nconfig.verbose &&= true;  // assigns only if truthy\n```"
    },
    {
      "name": "Optional Catch Binding",
      "example": "Demonstrates catch blocks without binding an error variable.\n\n```javascript\ntry {\n  throw new Error('Oops');\n} catch {\n  // Handle error without accessing the error object\n}\n```"
    },
    {
      "name": "Dynamic Module Import with Error Handling",
      "example": "Dynamically imports a module and gracefully handles errors.\n\n```javascript\nasync function loadModule(modulePath) {\n  try {\n    const module = await import(modulePath);\n    return module;\n  } catch (error) {\n    // Handle import error\n    console.error('Module load failed:', error);\n  }\n}\n\n// loadModule('./someModule.js');\n```"
    },
    {
      "name": "Recursive Iterator",
      "example": "Creates a generator that recursively flattens nested arrays.\n\n```javascript\nfunction* recursiveIterator(arr) {\n  for (const item of arr) {\n    if (Array.isArray(item)) {\n      yield* recursiveIterator(item);\n    } else {\n      yield item;\n    }\n  }\n}\n\n// Usage: [...recursiveIterator([1, [2, [3]]])] returns [1, 2, 3]\n```"
    },
    {
      "name": "Flatten Array with Reduce",
      "example": "Uses reduce to flatten a nested array one level deep.\n\n```javascript\nconst nested = [1, [2, 3], [4, [5]]];\nconst flat = nested.reduce((acc, val) => acc.concat(val), []);\n// flat is [1, 2, 3, 4, [5]]\n```"
    },
    {
      "name": "Memoization with Custom Resolver",
      "example": "Memoizes a function using a custom key resolver for caching.\n\n```javascript\nfunction memoizeWithResolver(fn, resolver = JSON.stringify) {\n  const cache = new Map();\n  return function(...args) {\n    const key = resolver(args);\n    if (cache.has(key)) return cache.get(key);\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Example usage: const fib = memoizeWithResolver(n => n <= 1 ? n : fib(n - 1) + fib(n - 2));\n```"
    },
    {
      "name": "Fluent Interface",
      "example": "Builds a chainable API for constructing queries or configurations.\n\n```javascript\nclass QueryBuilder {\n  constructor() {\n    this.query = '';\n  }\n  select(fields) {\n    this.query += `SELECT ${fields} `;\n    return this;\n  }\n  from(table) {\n    this.query += `FROM ${table} `;\n    return this;\n  }\n  where(condition) {\n    this.query += `WHERE ${condition} `;\n    return this;\n  }\n  build() {\n    return this.query.trim();\n  }\n}\n\n// Usage: new QueryBuilder().select('*').from('users').where('age > 20').build();\n```"
    },
    {
      "name": "WeakRef Usage",
      "example": "Uses WeakRef to hold a weak reference to an object (if supported by the environment).\n\n```javascript\nif (typeof WeakRef !== 'undefined') {\n  let obj = { data: 'important' };\n  const ref = new WeakRef(obj);\n  obj = null; // Now eligible for garbage collection\n  // ref.deref() may return undefined if GC has occurred\n}\n```"
    },
    {
      "name": "Node.js setImmediate Example",
      "example": "Demonstrates using setImmediate in a Node.js environment for scheduling.\n\n```javascript\nsetImmediate(() => {\n  // Executes after I/O events\n});\n```"
    },
    {
      "name": "Process.nextTick Example",
      "example": "Uses process.nextTick to schedule a callback before I/O events in Node.js.\n\n```javascript\nprocess.nextTick(() => {\n  // Executes before any I/O events\n});\n```"
    },
    {
      "name": "Private Methods in Class with Closures",
      "example": "Simulates private methods in a class using a closure.\n\n```javascript\nconst MyClass = (function() {\n  const privateMethod = () => 'secret';\n  return class {\n    publicMethod() {\n      return privateMethod();\n    }\n  };\n})();\n\n// new MyClass().publicMethod() returns 'secret'\n```"
    },
    {
      "name": "Basic Dependency Injection Container",
      "example": "Implements a simple dependency injection container.\n\n```javascript\nclass DIContainer {\n  constructor() {\n    this.services = new Map();\n  }\n  register(name, instance) {\n    this.services.set(name, instance);\n  }\n  get(name) {\n    return this.services.get(name);\n  }\n}\n\n// Usage: const container = new DIContainer();\n// container.register('logger', console);\n```"
    },
    {
      "name": "Computed Property Names in Object Literals",
      "example": "Defines dynamic property names in an object literal using computed keys.\n\n```javascript\nconst dynamicKey = 'score';\nconst obj = {\n  [dynamicKey]: 42\n};\n// obj.score is 42\n```"
    },
    {
      "name": "Negative Array Index with Proxy",
      "example": "Simulates negative indexing for arrays using a Proxy.\n\n```javascript\nconst negativeIndexArray = new Proxy([10, 20, 30], {\n  get(target, prop) {\n    const index = Number(prop);\n    if (index < 0) {\n      return target[target.length + index];\n    }\n    return target[prop];\n  }\n});\n\n// negativeIndexArray[-1] returns 30\n```"
    },
    {
      "name": "Async/Await with Retry Logic",
      "example": "Retries an async operation a set number of times before failing.\n\n```javascript\nasync function fetchWithRetry(url, retries = 3) {\n  for (let i = 0; i < retries; i++) {\n    try {\n      const response = await fetch(url);\n      return await response.json();\n    } catch (error) {\n      if (i === retries - 1) throw error;\n    }\n  }\n}\n\n// Usage: fetchWithRetry('https://api.example.com/data');\n```"
    },
    {
      "name": "Tree Traversal with Recursion (DFS)",
      "example": "Performs a depth-first search on a tree structure.\n\n```javascript\nfunction dfs(node, visit = console.log) {\n  if (!node) return;\n  visit(node.value);\n  if (node.children) {\n    node.children.forEach(child => dfs(child, visit));\n  }\n}\n\n// Example tree node: { value: 1, children: [{ value: 2 }, { value: 3 }] }\n```"
    },
    {
      "name": "Generator for Infinite Sequence",
      "example": "Creates a generator that yields an infinite sequence of numbers.\n\n```javascript\nfunction* infiniteSequence() {\n  let i = 0;\n  while (true) {\n    yield i++;\n  }\n}\n\n// Usage: const gen = infiniteSequence(); gen.next().value returns increasing numbers\n```"
    },
    {
      "name": "Debounce with Leading and Trailing Options",
      "example": "Enhances a debounce function to support both leading and trailing calls.\n\n```javascript\nfunction debounceEnhanced(fn, delay, options = { leading: false, trailing: true }) {\n  let timeout, lastArgs;\n  return function(...args) {\n    const callNow = options.leading && !timeout;\n    lastArgs = args;\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      if (options.trailing) fn.apply(this, lastArgs);\n      timeout = null;\n    }, delay);\n    if (callNow) fn.apply(this, args);\n  };\n}\n\n// Usage: const debounced = debounceEnhanced(myFunction, 300, { leading: true, trailing: false });\n```"
    },
    {
      "name": "Throttle with Trailing Execution",
      "example": "Throttles a function and ensures the last call is executed after the interval.\n\n```javascript\nfunction throttleEnhanced(fn, interval) {\n  let lastCall = 0, timeout, lastArgs;\n  return function(...args) {\n    const now = Date.now();\n    lastArgs = args;\n    const remaining = interval - (now - lastCall);\n    if (remaining <= 0) {\n      clearTimeout(timeout);\n      lastCall = now;\n      fn.apply(this, args);\n    } else if (!timeout) {\n      timeout = setTimeout(() => {\n        lastCall = Date.now();\n        timeout = null;\n        fn.apply(this, lastArgs);\n      }, remaining);\n    }\n  };\n}\n\n// Usage: const throttled = throttleEnhanced(myFunction, 200);\n```"
    },
    {
      "name": "Batching Function Calls",
      "example": "Batches multiple calls to a function and processes them together.\n\n```javascript\nfunction batchCalls(fn, delay = 100) {\n  let calls = [];\n  let timeout;\n  return function(arg) {\n    calls.push(arg);\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      fn(calls);\n      calls = [];\n    }, delay);\n  };\n}\n\n// Usage: batchCalls(console.log) will log an array of arguments after the delay\n```"
    },
    {
      "name": "Redux-like Store Implementation",
      "example": "Implements a simple state store similar to Redux.\n\n```javascript\nclass Store {\n  constructor(reducer, initialState) {\n    this.reducer = reducer;\n    this.state = initialState;\n    this.listeners = [];\n  }\n  dispatch(action) {\n    this.state = this.reducer(this.state, action);\n    this.listeners.forEach(listener => listener());\n  }\n  subscribe(listener) {\n    this.listeners.push(listener);\n  }\n  getState() {\n    return this.state;\n  }\n}\n\n// Usage: const store = new Store((state, action) => { ... }, {});\n```"
    },
    {
      "name": "Basic Observable Implementation",
      "example": "Creates a simple observable pattern to manage subscriptions.\n\n```javascript\nclass Observable {\n  constructor() {\n    this.subscribers = [];\n  }\n  subscribe(fn) {\n    this.subscribers.push(fn);\n  }\n  notify(data) {\n    this.subscribers.forEach(fn => fn(data));\n  }\n}\n\n// Usage: const obs = new Observable(); obs.subscribe(data => console.log(data));\n```"
    },
    {
      "name": "Experimental Decorators in Classes",
      "example": "Uses experimental decorators to modify class methods (requires transpiler support).\n\n```javascript\nfunction readonly(target, key, descriptor) {\n  descriptor.writable = false;\n  return descriptor;\n}\n\nclass Example {\n  @readonly\n  method() {\n    return 'This is read-only';\n  }\n}\n```"
    },
    {
      "name": "Promise.race Timeout",
      "example": "Implements a timeout for a promise using Promise.race.\n\n```javascript\nfunction promiseTimeout(promise, ms) {\n  const timeout = new Promise((_, reject) =>\n    setTimeout(() => reject(new Error('Timeout')), ms)\n  );\n  return Promise.race([promise, timeout]);\n}\n\n// Usage: promiseTimeout(fetch(url), 5000);\n```"
    },
    {
      "name": "Cancellation Token for Async Operations",
      "example": "Implements a basic cancellation token mechanism to cancel async work.\n\n```javascript\nclass CancellationToken {\n  constructor() {\n    this.cancelled = false;\n  }\n  cancel() {\n    this.cancelled = true;\n  }\n}\n\nasync function fetchWithCancel(url, token) {\n  while (!token.cancelled) {\n    // Simulate async work\n    await new Promise(r => setTimeout(r, 100));\n    // Break if work is done\n    return 'data';\n  }\n  throw new Error('Cancelled');\n}\n\n// Usage: const token = new CancellationToken(); fetchWithCancel(url, token);\n```"
    },
    {
      "name": "Object.fromEntries Usage",
      "example": "Converts an array of key-value pairs into an object using Object.fromEntries.\n\n```javascript\nconst entries = [['a', 1], ['b', 2]];\nconst obj = Object.fromEntries(entries);\n// obj is { a: 1, b: 2 }\n```"
    },
    {
      "name": "Async/Await with WebSocket",
      "example": "Wraps WebSocket events using promises and async/await.\n\n```javascript\nfunction openWebSocket(url) {\n  return new Promise((resolve, reject) => {\n    const ws = new WebSocket(url);\n    ws.onopen = () => resolve(ws);\n    ws.onerror = (err) => reject(err);\n  });\n}\n\nasync function sendMessage(url, message) {\n  const ws = await openWebSocket(url);\n  ws.send(message);\n  // Handle responses via ws.onmessage\n}\n\n// sendMessage('wss://example.com', 'Hello');\n```"
    },
    {
      "name": "Job Queue Implementation",
      "example": "Implements a simple job queue to process async tasks sequentially.\n\n```javascript\nclass JobQueue {\n  constructor() {\n    this.queue = [];\n    this.running = false;\n  }\n  add(job) {\n    this.queue.push(job);\n    this.run();\n  }\n  async run() {\n    if (this.running) return;\n    this.running = true;\n    while (this.queue.length) {\n      const job = this.queue.shift();\n      await job();\n    }\n    this.running = false;\n  }\n}\n\n// Usage: const queue = new JobQueue();\n// queue.add(async () => { /* task */ });\n```"
    },
    {
      "name": "Remove Duplicates with Set",
      "example": "Removes duplicate elements from an array using the Set data structure.\n\n```javascript\nconst numbers = [1, 2, 2, 3, 3, 3];\nconst unique = [...new Set(numbers)];\n// unique is [1, 2, 3]\n```"
    }
  ]
}
